<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SOMC</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_SOMC.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Julius Quasebarth, Robin Hankel, Luisa Derer 2015</td></tr><tr><th>License</th><td>GPL-3</td></tr><tr><th>Maintainer</th><td>feldrandstudios@gmail.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>No restrictions</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">SOMC</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Basic Types</a></li><li><a href="#g:2">Functions for working with Vectors</a></li><li><a href="#g:3">Working with Multi-Dimensional Coordinate Systems</a><ul><li><a href="#g:4">Using Self-Organizing Memory Cards</a></li><li><a href="#g:5">Processing Multi-Dimensional Coordinate Systems</a></li><li><a href="#g:6">Auxiliary Functions</a><ul><li><a href="#g:7">Base Alpha Functions</a></li><li><a href="#g:8">Prototype Space Interpretations</a></li><li><a href="#g:9">Epoch-Based Radius Functions</a></li><li><a href="#g:10">Radius-Based Alpha Functions</a></li></ul></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This package exports functions to group and manipulate points in
multi-dimensional space using <strong>s</strong>elf-<strong>o</strong>rganizing <strong>m</strong>emory <strong>c</strong>ards.</p><p>To understand the mechanics of most functions, it is necessary to understand how
a self-organizing memory card works, at least how it works in this project.</p><p><h2>Understanding Self-Organizing Memory Cards</h2></p><p><h3>What you want to do, and what you need for it</h3></p><p>You want to group data. For this reason, you obviously need two components:
Data, and you have to know how many groups you want.</p><p>But before you can group your data, you need a list of prototypes. Prototypes
are essential to grouping data with memory cards, because they are the
representation of groups. Thus you need as many prototypes as groups.
Furthermore, prototypes contain a representation point in &quot;data space&quot; (space
for data points) and a prototype position in &quot;prototype space&quot;. It is a
convention to initialize the data space with random values, while the prototypes
are aligned tidily in prototype space.</p><p><h3>Getting to the point</h3></p><p>Because a self-organizing memory card is a type of neural network, it works by
training. It is trained by going through every data point in your data set and
moving the prototype closest to the data point a bit more in that direction.
There is a problem with that: The resulting groups (prototypes) are not ordered
at all. You can fix that by doing the following: If you move a prototype (lets
call it &quot;the winner&quot;), you move all prototypes near the winner slightly to the
direction of the point the winner moves to. And with &quot;near&quot; I mean close in
another space, the <em>prototype space</em>! In the prototype space, all prototypes are
aligned on a grid. Using this technique, prototypes next to each other in
prototype space will always be next to each other in data space, too.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Vec">Vec</a> a = [a]</li><li class="src short"><span class="keyword">type</span> <a href="#t:DataPoint">DataPoint</a> = <a href="SOMC.html#t:Vec">Vec</a> Double</li><li class="src short"><span class="keyword">type</span> <a href="#t:DataSet">DataSet</a> = Set <a href="SOMC.html#t:DataPoint">DataPoint</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Prototype">Prototype</a></li><li class="src short"><a href="#v:-45--64--62-">(-@&gt;)</a> :: [Double] -&gt; [Int] -&gt; <a href="SOMC.html#t:Prototype">Prototype</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Prototypes">Prototypes</a> = [<a href="SOMC.html#t:Prototype">Prototype</a>]</li><li class="src short"><span class="keyword">type</span> <a href="#t:MDCS">MDCS</a> = (<a href="SOMC.html#t:DataSet">DataSet</a>, <a href="SOMC.html#t:Prototypes">Prototypes</a>)</li><li class="src short"><a href="#v:-62--43-">(&gt;+)</a> :: Num a =&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a</li><li class="src short"><a href="#v:-62--45-">(&gt;-)</a> :: Num a =&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a</li><li class="src short"><a href="#v:-62--42-">(&gt;*)</a> :: Num a =&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a</li><li class="src short"><a href="#v:absv">absv</a> :: Floating a =&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; a</li><li class="src short"><a href="#v:getWinner">getWinner</a> :: (<a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double) -&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:Prototype">Prototype</a></li><li class="src short"><a href="#v:updateWinner">updateWinner</a> :: (<a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double) -&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a> -&gt; <a href="SOMC.html#t:Prototype">Prototype</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a></li><li class="src short"><a href="#v:epoch">epoch</a> :: (<a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double) -&gt; (<a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double) -&gt; <a href="SOMC.html#t:MDCS">MDCS</a> -&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a></li><li class="src short"><a href="#v:train">train</a> :: (<a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double) -&gt; (Int -&gt; Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double) -&gt; <a href="SOMC.html#t:MDCS">MDCS</a> -&gt; Int -&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a></li><li class="src short"><a href="#v:sortToGroups">sortToGroups</a> :: (<a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double) -&gt; <a href="SOMC.html#t:MDCS">MDCS</a> -&gt; [(<a href="SOMC.html#t:Prototype">Prototype</a>, <a href="SOMC.html#t:DataSet">DataSet</a>)]</li><li class="src short"><a href="#v:printSet">printSet</a> :: Show a =&gt; Set a -&gt; IO ()</li><li class="src short"><a href="#v:printList">printList</a> :: Show a =&gt; [a] -&gt; IO ()</li><li class="src short"><a href="#v:euclidDistance">euclidDistance</a> :: <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double</li><li class="src short"><a href="#v:quadraticAlpha">quadraticAlpha</a> :: (Int -&gt; Int -&gt; Int) -&gt; (Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double) -&gt; Double -&gt; Int -&gt; Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</li><li class="src short"><a href="#v:reversedAlpha">reversedAlpha</a> :: (Int -&gt; Int -&gt; Int) -&gt; (Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double) -&gt; Double -&gt; Int -&gt; Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</li><li class="src short"><a href="#v:linearAlpha">linearAlpha</a> :: (Int -&gt; Int -&gt; Int) -&gt; (Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double) -&gt; Double -&gt; Int -&gt; Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</li><li class="src short"><a href="#v:squareInterpretation">squareInterpretation</a> :: (Double -&gt; Int -&gt; Int -&gt; Double) -&gt; Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</li><li class="src short"><a href="#v:independentInterpretation">independentInterpretation</a> :: Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</li><li class="src short"><a href="#v:hexagonalInterpretation">hexagonalInterpretation</a> :: (Double -&gt; Int -&gt; Int -&gt; Double) -&gt; Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</li><li class="src short"><a href="#v:squareRadius">squareRadius</a> :: Int -&gt; Int -&gt; Int -&gt; Int</li><li class="src short"><a href="#v:squareRadiusDistribution">squareRadiusDistribution</a> :: Double -&gt; Double -&gt; Double -&gt; Int -&gt; Int -&gt; Double</li></ul></div><div id="interface"><h1 id="g:1">Basic Types</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Vec" class="def">Vec</a> a = [a]</p><div class="doc"><p>This type assignment is used to provide more intuitive working with vectors.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:DataPoint" class="def">DataPoint</a> = <a href="SOMC.html#t:Vec">Vec</a> Double</p><div class="doc"><p>A point in multi-dimensional space.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:DataSet" class="def">DataSet</a> = Set <a href="SOMC.html#t:DataPoint">DataPoint</a></p><div class="doc"><p>This type assignment is used for more intuitive typing, too.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Prototype" class="def">Prototype</a></p><div class="doc"><p>A prototype in multi-dimensional space. It both uses a &quot;represenation
  point&quot; and a &quot;position in prototype space&quot;. The &quot;representation point&quot;
  is (or should be) the middle of a group of data points, whereas the position
  in prototype space is used for regularly distributing representation points
  in data point space. This is done by moving prototypes close to each other
  in prototype space near to each other in data point space.</p></div><div class="subs instances"><p id="control.i:Prototype" class="caption collapser" onclick="toggleSection('i:Prototype')">Instances</p><div id="section.i:Prototype" class="show"><table><tr><td class="src">Eq <a href="SOMC.html#t:Prototype">Prototype</a></td><td class="doc"><p>Two prototypes are equal if their position in prototype space is equal.</p></td></tr><tr><td class="src">Show <a href="SOMC.html#t:Prototype">Prototype</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:-45--64--62-" class="def">(-@&gt;)</a> :: [Double] -&gt; [Int] -&gt; <a href="SOMC.html#t:Prototype">Prototype</a></p><div class="doc"><p>The prototype assignment operator just says &quot;clip this data point to that
  prototype position&quot;.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Prototypes" class="def">Prototypes</a> = [<a href="SOMC.html#t:Prototype">Prototype</a>]</p><div class="doc"><p>This type assignment is used for more intuitive typing <code>:)</code>.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:MDCS" class="def">MDCS</a> = (<a href="SOMC.html#t:DataSet">DataSet</a>, <a href="SOMC.html#t:Prototypes">Prototypes</a>)</p><div class="doc"><p><strong>M</strong>ulti-<strong>D</strong>imensional <strong>C</strong>oordinate <strong>S</strong>ystem.
  This type assignment is used to combine both data of the data space and
  prototypes of prototype space.</p></div></div><h1 id="g:2">Functions for working with Vectors</h1><div class="top"><p class="src"><a name="v:-62--43-" class="def">(&gt;+)</a> :: Num a =&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a</p><div class="doc"><p>Add two vectors. This is defined as <code>(&gt;+) = zipWith (+)</code>.</p></div></div><div class="top"><p class="src"><a name="v:-62--45-" class="def">(&gt;-)</a> :: Num a =&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a</p><div class="doc"><p>Subtract two vectors. This is defined as <code>(&gt;-) = zipWith (-)</code>.</p></div></div><div class="top"><p class="src"><a name="v:-62--42-" class="def">(&gt;*)</a> :: Num a =&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; a -&gt; <a href="SOMC.html#t:Vec">Vec</a> a</p><div class="doc"><p>Multiply vector by a scalar. This is defined as <code>(&gt;*) x y = map (y *) x</code>.</p></div></div><div class="top"><p class="src"><a name="v:absv" class="def">absv</a> :: Floating a =&gt; <a href="SOMC.html#t:Vec">Vec</a> a -&gt; a</p><div class="doc"><p>Length of vector, calculated using the euclidean distance.</p></div></div><h1 id="g:3">Working with Multi-Dimensional Coordinate Systems</h1><h2 id="g:4">Using Self-Organizing Memory Cards</h2><div class="top"><p class="src"><a name="v:getWinner" class="def">getWinner</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double)</td><td class="doc"><p>A function which takes the
  position of the data point
  and the representation point
  of a prototype and returns
  the distance of both
  (&quot;distance function&quot;).</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a></td><td class="doc"><p>The prototypes to choose from.</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a></td><td class="doc"><p>The data point to compare with.</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:Prototype">Prototype</a></td><td class="doc"><p>The &quot;winning&quot; prototype.</p></td></tr></table></div><div class="doc"><p>Returns the prototype for which the given function returns the lowest value.</p></div></div><div class="top"><p class="src"><a name="v:updateWinner" class="def">updateWinner</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double)</td><td class="doc"><p>The radius function. It
  takes the position of the
  winner prototype and the
  position of any prototype in
  prototype space and returns
  how much (relative) the
  prototype should be moved.</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a></td><td class="doc"><p>The prototype list to choose from.</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:Prototype">Prototype</a></td><td class="doc"><p>The winning prototype.</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a></td><td class="doc"><p>The data point to in which direction the
  prototypes should be moved.</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a></td><td class="doc"><p>The modified prototype list.</p></td></tr></table></div><div class="doc"><p>Updates a prototype given a &quot;radius function&quot; (a distance function for
  prototype space), a list of available prototypes, the &quot;winner&quot; prototype
  and a data point. Essentially, this function first generates a vector from
  any prototype to the given data point and then moves the prototype by a
  fraction of that vector, whereas the fraction is given by the radius
  function.</p></div></div><div class="top"><p class="src"><a name="v:epoch" class="def">epoch</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double)</td><td class="doc"><p>The distance function, as
  discussed with the <code><a href="SOMC.html#v:getWinner">getWinner</a></code>
  function.</p></td></tr><tr><td class="src">-&gt; (<a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double)</td><td class="doc"><p>The radius function, as
  discussed with the <code><a href="SOMC.html#v:updateWinner">updateWinner</a></code>
  function.</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:MDCS">MDCS</a></td><td class="doc"><p>The MDCS containing data points and prototypes.</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a></td><td class="doc"><p>The trained prototype list.</p></td></tr></table></div><div class="doc"><p>Trains the self-organizing memory card in one &quot;epoch&quot;. An epoch is a
  training cycle, so for every given data point, the nearest prototype is
  determined (using the <code><a href="SOMC.html#v:getWinner">getWinner</a></code> function) and then all prototypes are
  updated (based on the <code><a href="SOMC.html#v:updateWinner">updateWinner</a></code> function).</p></div></div><div class="top"><p class="src"><a name="v:train" class="def">train</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double)</td><td class="doc"><p>distance function</p></td></tr><tr><td class="src">-&gt; (Int -&gt; Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double)</td><td class="doc"><p>Radius function, enhanced by two arguments: The first
 one is the amount of training cycles, the second is the
 current training cycle (as the output of this function
 should change over time).</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:MDCS">MDCS</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc"><p>amount of training cycles</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:Prototypes">Prototypes</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A function for training a SOM. It iterates the epoch-function.</p></div></div><h2 id="g:5">Processing Multi-Dimensional Coordinate Systems</h2><div class="top"><p class="src"><a name="v:sortToGroups" class="def">sortToGroups</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double)</td><td class="doc"><p>The distance function,
  as discussed with the
  <code><a href="SOMC.html#v:getWinner">getWinner</a></code> function.</p></td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:MDCS">MDCS</a></td><td class="doc"><p>The MDCS containing data points to sort and
  prototypes to sort to.</p></td></tr><tr><td class="src">-&gt; [(<a href="SOMC.html#t:Prototype">Prototype</a>, <a href="SOMC.html#t:DataSet">DataSet</a>)]</td><td class="doc"><p>The data points of the data set
  of the MDCS, assigned to the
  protoypes.</p></td></tr></table></div><div class="doc"><p>This function sorts the data points of a MDCS to groups by going through
  every data point in the <code><a href="SOMC.html#t:DataSet">DataSet</a></code> and then assigning it to the prototype
  which representation point is the closest to the data point.</p></div></div><h2 id="g:6">Auxiliary Functions</h2><div class="doc"><p>The following functions can be used to build customized training functions.
 It is important to understand how they work together, so they can be built
 together correctly. <code><a href="SOMC.html#v:train">train</a></code> and <code><a href="SOMC.html#v:epoch">epoch</a></code> both use alpha-functions which
 tell how far a prototype has to be moved. As the names of <code><a href="SOMC.html#v:quadraticAlpha">quadraticAlpha</a></code>,
 <code><a href="SOMC.html#v:reversedAlpha">reversedAlpha</a></code> and <code><a href="SOMC.html#v:linearAlpha">linearAlpha</a></code> suggest, these are the most important
 parts of configuration. Their types are equal. They all take a radius function
 , a radius-based alpha function and a initial alpha value and return a
 configured alpha function. Radius functions are constructed using <code><a href="SOMC.html#v:squareRadius">squareRadius</a></code>
 or similar functions. Radius-based alpha functions are constructed using
 an interpretation, for example <code><a href="SOMC.html#v:squareInterpretation">squareInterpretation</a></code>. But an interpretation
 also needs to know how the alpha value should change with greater radius, so
 it needs a radius-based alpha distribution. So a complete alpha function could
 look like <code>quadraticAlpha (squareRadius 3) (hexagonalInterpretation
 squareRadiusDistribution) 0.3</code>.</p></div><div class="top"><p class="src"><a name="v:printSet" class="def">printSet</a> :: Show a =&gt; Set a -&gt; IO ()</p><div class="doc"><p>Prints a set in a neat way by just printing every element, so the developer
  can see what the set contains in an easy way.</p></div></div><div class="top"><p class="src"><a name="v:printList" class="def">printList</a> :: Show a =&gt; [a] -&gt; IO ()</p><div class="doc"><p>Works the same es <code><a href="SOMC.html#v:printSet">printSet</a></code>, just with lists.</p></div></div><div class="top"><p class="src"><a name="v:euclidDistance" class="def">euclidDistance</a> :: <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; <a href="SOMC.html#t:DataPoint">DataPoint</a> -&gt; Double</p><div class="doc"><p>Calculates the euclidean distance between two points, using the <code><a href="SOMC.html#v:absv">absv</a></code>
  function.</p></div></div><h3 id="g:7">Base Alpha Functions</h3><div class="top"><p class="src"><a name="v:quadraticAlpha" class="def">quadraticAlpha</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (Int -&gt; Int -&gt; Int)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; (Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double)</td><td class="doc"><p>A function which takes a radius and an alpha value and
  returns a radius-based alpha function.</p></td></tr><tr><td class="src">-&gt; Double</td><td class="doc"><p>A initial alpha value. It decreases quadratically, which
 means it starts to decrease slowly and then faster.</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:Vec">Vec</a> Int</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="SOMC.html#t:Vec">Vec</a> Int</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Double</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A epoch-based alpha distribution using quadratic functions for underlying calculations.</p></div></div><div class="top"><p class="src"><a name="v:reversedAlpha" class="def">reversedAlpha</a> :: (Int -&gt; Int -&gt; Int) -&gt; (Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double) -&gt; Double -&gt; Int -&gt; Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</p><div class="doc"><p>This epoch-based alpha distribution is unique, because it does not depend
 on the amount of training epochs, but rather decreases like <code>1/x</code>. The more
 training samples there are, the more accurate are the results.</p></div></div><div class="top"><p class="src"><a name="v:linearAlpha" class="def">linearAlpha</a> :: (Int -&gt; Int -&gt; Int) -&gt; (Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double) -&gt; Double -&gt; Int -&gt; Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</p><div class="doc"><p>This epoch-based alpha distribution uses a linearly decreasing alpha value.</p></div></div><h3 id="g:8">Prototype Space Interpretations</h3><div class="top"><p class="src"><a name="v:squareInterpretation" class="def">squareInterpretation</a> :: (Double -&gt; Int -&gt; Int -&gt; Double) -&gt; Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</p><div class="doc"><p>A radius interpretation using squares as prototype &quot;tiles&quot;.</p></div></div><div class="top"><p class="src"><a name="v:independentInterpretation" class="def">independentInterpretation</a> :: Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</p><div class="doc"><p>A function taking an alpha value returning a radius-based alpha function, as discussed
  with the <code><a href="SOMC.html#v:updateWinner">updateWinner</a></code> function. <code>independentRadius a w t</code> returns <code>a</code> if
  <code>t == w</code>, and <code>0</code> if <code>t /= w</code>. In other words, only the winning prototype is
  updated with an alpha factor of <code>a</code>.</p></div></div><div class="top"><p class="src"><a name="v:hexagonalInterpretation" class="def">hexagonalInterpretation</a> :: (Double -&gt; Int -&gt; Int -&gt; Double) -&gt; Int -&gt; Double -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; <a href="SOMC.html#t:Vec">Vec</a> Int -&gt; Double</p><div class="doc"><p>A radius interpretation using hexagonal &quot;tiles&quot; for the prototypes.</p></div></div><h3 id="g:9">Epoch-Based Radius Functions</h3><div class="top"><p class="src"><a name="v:squareRadius" class="def">squareRadius</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Int</td><td class="doc"><p>starting radius</p></td></tr><tr><td class="src">-&gt; Int</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>A radius-based alpha distribution using a quadratic function for underlying calculations.</p></div></div><h3 id="g:10">Radius-Based Alpha Functions</h3><div class="top"><p class="src"><a name="v:squareRadiusDistribution" class="def">squareRadiusDistribution</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: Double</td><td class="doc"><p>A regulating variable between (!) 0 and (about) 0.5, stating
 how curvy the parabola should be. If this value is
 <code>r</code> and the following value is <code>e</code>, then the parabola
 goes through the points (0|1), (0.5|r) and (1|e),
 whereas 1 at the y-axis is the maximum radius possible
 and 1 at the x-axis is the maximum alpha possible.</p></td></tr><tr><td class="src">-&gt; Double</td><td class="doc"><p>A regulating variable between 0 and the previous
 variable, stating how low the parabola should go
 at the maximum radius possible: If this value is
 called <code>e</code> and the maximum alpha value possible
 is <code>a</code>, then the outermost prototype is moved
 by <code>e*a</code>.</p></td></tr><tr><td class="src">-&gt; Double</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Int</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; Double</td><td class="doc"><p>The final radius-based alpha distribution.</p></td></tr></table></div><div class="doc"><p>A distribution of the alpha value throughout different radii. It can be
 viewed as a graph of a parabola, whereas radii are noted on the x-axis and
 alpha values are noted on the y-axis.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>