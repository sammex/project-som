%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% * <feldrandstudios@gmail.com> 2015-01-30T20:40:28.601Z:
%
%
%
% Version 1.3 (9/9/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[twoside,a4paper,draft]{article}

% --- DOC CONFIG ---

\usepackage[sc]{mathpazo}
\usepackage[T1]{fontenc}
\linespread{1.05}
\usepackage[protrusion=true,expansion=true,final]{microtype}

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry}
\usepackage{multicol}
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption}
\usepackage{booktabs}
\usepackage{float}
\usepackage{hyperref}

\usepackage{lettrine}
\usepackage{paralist}

\usepackage{abstract}

\usepackage{titlesec}
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{}
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[C]{Selbstorganisierende Karten \(\bullet\) 2014 / 2015 \(\bullet\) ASG Spez.}
\fancyfoot[RO,LE]{\thepage}

\usepackage[english,german]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm,amsfonts}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}

\usepackage{texments}
\usestyle{colorful}

% --- LITTLE TWEAKS ---

\renewcommand{\abstractnamefont}{\normalfont\bfseries}
\renewcommand{\abstracttextfont}{\normalfont\small\itshape}

\renewcommand{\thesection}{\Roman{section}}
\renewcommand{\thesubsection}{\arabic{subsection}}

\newcommand{\commonlettrine}[1]{\lettrine[nindent=0em,lines=2]{#1}}

% --- DOCUMENT INFORMATION ---

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\bfseries{}Buchempfehlungen mit Hilfe von selbstorganisierenden Karten erstellen}

\author{\large\textsc{Julius Quasebarth \quad Luisa Derer \quad Robin Hankel}\thanks{Projektbetreuer: Johannes Suepke, Außenbetreuer: ???}\\[2mm]\normalsize Alber Schweitzer Gymnasium Erfurt (Spez.)\\\vspace{-5mm}}

\date{2014 / 2015}

% --- BEGIN OF DOCUMENT ---

\begin{document}

\maketitle

\thispagestyle{fancy}

% --- BEGIN OF TEXT ---

\begin{otherlanguage}{english}
\begin{abstract}
\noindent
Our super duper cool abstract text...
\end{abstract}
\end{otherlanguage}

\tableofcontents

\section{Einleitung}

\commonlettrine{J}eder kennt das Gefühl der Leere nach dem Lesen eines Buches. Welches Buch soll man sich als nächstes vornehmen? In dieser Seminarfacharbeit lösen wir dieses Problem: Es geht um Buchempfehlungen mit Hilfe von selbstorganisierenden Karten. Mit diesem mathematischen Prinzip lassen sich Punkt im n-dimensionalem Raum in beliebig viele Gruppen unterteilen, wodurch sich Gruppen von Personen mit ähnlichen Lesevorzügen erstellen lassen. Je nachdem, welche Bücher die Personen bereits gelesen haben, kann somit ein \glqq{}Pool\grqq{} aus Büchern erstellt werden. In unserer Seminarfacharbeit wird vor allem auf die Erstellung des Programms, das Sammeln von Daten dafür und die Anwendung dessen eingegangen.

\section{Mathematische Prinzipien der selbstorganisierenden Karte}
\subsection{Neuronale Netze --- Grundlagen für ein besseres Verständnis}

\commonlettrine{D}ie selbstorganisierende Karte ist vom Prinzip her ein neuronales Netz, welches, anders als \glqq{}normale\grqq{} neuronale Netze (wie z.B. das Backpropagation-Netz), unüberwacht lernt und deren Ergebnisse stark von der Anordnung der Neuronen abhängig sind. Doch was bedeutet das überhaupt? Was ist ein neuronales Netzwerk, was heißt \glqq{}unüberwacht\grqq{} und warum sind die Ausgaben des Netzwerkes von der Anordnung der Neuronen abhängig?

Ein neuronales Netzwerk ist ein Netzwerk aus Neuronen, das heißt, die Neuronen sind miteinander über sogenannte Synapsen bzw. Gewichte verbunden (diese Begriffe werden Synonym verwendet). Die Synapsen verbinden die Ausgänge der Neuronen mit den Eingängen (meist) anderer Neuronen (es können manchmal auch Verbindungen von einem Neuron zu demselben vorhanden sein). Sie übertragen Daten, diese sind normalerweise rationale Zahlen (also Zahlen, die sich als Bruch darstellen lassen). Ein Neuron erhält nun folgende Eingaben: Die Daten, die andere Neuronen über die Synapsen zu ihm schicken, und die \glqq{}Gewichte\grqq{} dieser Synapsen --- dies sind Konstanten, die jeder Synapse zugeordnet werden können. Mit speziellen Funktionen kann das Neuron nun diese Daten verarbeiten und zu einem Wert kombinieren (mit Hilfe einer sogenannten Propagierungsfunktion), den es dann über seine Ausgabesynapsen ausgibt (dieser Wert wird durch die Aktivierungsfunktion berechnet). Da ein neuronales Netzwerk noch Eingaben von außen benötigt, um jene Eingaben zu verarbeiten, existieren Spezialfälle: So gibt es Eingabeneuronen, die lediglich das ausgeben (oder \glqq{}feuern\grqq{}), was man selbst bestimmt, ebenso wie Ausgabeneuronen, die ihre Ausgaben nicht wieder in das neuronale Netz einspeisen, sondern in die reale Welt ausgeben.

Das Besondere an neuronalen Netzen ist, dass diese lernen können. Dazu gibt es spezielle Algorithmen, wie etwa den Backpropagation-Algorithmus: Dabei wird versucht, herauszufinden, wie man das neuronale Netz verbessern kann, indem man bestimmt, welches Neuron welchen \emph{Fehler} im neuronalen Netz verursacht hat. Man speist Eingaben, zu denen man die optimalen Ausgaben kennt, in das neuronale Netz ein und vergleicht die Ausgaben des neuronalen Netzes mit den erwarteten Ausgaben. Danach kann man bestimmen, welches Neuron wie stark zu dem Unterschied zwischen gewünschten und tatsächlichen Ausgaben beigetragen hat und darauf basierend die Gewichte zwischen den Neuronen ändern. Da das neuronale Netz bei diesem Algorithmus nach einem vorgegebenem Ausgabemuster trainiert wird, lernt das Netz \glqq{}überwacht\grqq{}.

Im Gegenteil dazu steht das unüberwachte Lernen. Dabei geht es oft darum, Daten zu gruppieren und einzuordnen. Zum Beispiel kann ein neuronales Netz, das unüberwacht lernt, mit den Bildern von Buchstaben trainiert werden und anschließend andere Bilder in diese Buchstabengruppen einsortieren.

\subsection{Die selbstorganisierende Karte im Vergleich zu anderen neuronalen Netzwerken}

\commonlettrine{D}ie selbstorganisierende Karte, eine besondere Form eines neuronalen Netzes, lernt auch unüberwacht. Sie ist aus zwei Schichten von Neuronen aufgebaut, das heißt, jedes Neuron aus einer Schicht ist mit jedem Neuron aus einer anderen Schicht verbunden, jedoch sind die Neuronen aus einer Schicht untereinander nicht verbunden. Die erste Schicht, Eingabeschicht genannt, ist besetzt mit \(n\) Eingabeneuronen, wobei \(n\) die Anzahl von Dimensionen ist, die die zu gruppierenden Punkte haben sollen. Die zweite Schicht, Kohonenkarte genannt, besteht aus Neuronen, die die Gruppen repräsentieren; Die Gewichte von jedem Eingabeneuron zu einem Neuron \(k\) aus der Kohonenkarte sind dabei als Koordinaten im Raum zu verstehen. Alle Punkte, die näher an dieser Koordinate sind als an Koordinaten anderer Punkte, gehören zur Gruppe \(k\)s. Wenn die Propagierungsfunktion eines jeden Neurons aus der Kohonenkarte also
\[
\sqrt{\sum_{i\in{}E} \left((w_{i\rightarrow{}k} - v_i)^2\right)}
\]
lautet\footnote{Diese Funktion spiegelt letztendlich den euklidischen Abstand von dem eingegebenem Punkt zum Repräsentationspunkt des betrachteten Neurons aus der Kohonenschicht wider.} (wobei \(w_{i\rightarrow{}j}\) das Gewicht von Neuron \(i\) zu Neuron \(j\), \(v_i\) die Ausgabe des Neurons \(i\) und \(E\) die Menge der Eingabeneuronen bezeichnet), dann gehört der Punkt, der durch die Eingabeneuronen definiert wurde, zu dem Neuron aus der Kohonenschicht, welches den geringsten Ausgabewert hat (dieses soll mit \glqq{}Gewinnerneuron\grqq{} bezeichnet werden).

Die selbstorganisierende Karte lernt, indem der Repräsentationspunkt eines Neurons der Kohonenkarte verschoben wird. Dazu gibt man ein Eingabemuster in das Netz ein und verschiebt den Repräsentationspunkt des Gewinnerneurons um einen bestimmten Anteil in Richtung des eingegebenen Punktes. Interessant hierbei ist, dass auch Neuronen in der unmittelbaren Umgebung des Gewinnerneurons in Richtung des eingegebenen Punktes verschoben werden können: Somit können sich die Repräsentationspunkte im Raum auf ähnliche Weise anordnen, wie die Neuronen der Kohonenschicht angeordnet sind.

\section{Anwendung der Prinzipien der selbstorganisierenden Karte}

Natürlich finden die oben beschriebenen Prinzipien auch in der Praxis Anwendung. Besonders, wenn Informationen vorverarbeitet werden müssen, wenn milliarden Datenpunkte zu wenigen tausend umgewandelt werden sollen, sind selbstorganisierende Karten von Bedeutung. Sie gruppieren Daten, um Auffälligkeiten und Muster in der Verteilung dieser aufzudecken. Weil selbstorganisierende Karten jedoch so viele Daten verarbeiten müssen, lohnt es sich auch, diese besonders effizient zu gestalten. Wie kann man also eine selbstorganisierende Karte simulieren, ohne unnötige Rechenzeit zu verbrauchen?

Das wichtigste Stichwort zur Antwort auf diese Frage ist Minimalismus. Unnötige Konstruktionen werden nicht gebraucht, also auch nicht umgesetzt. Daher muss man überlegen, welche Teile der Grundlagen vereinfachbar sind und welche nicht. Zum Beispiel muss man nicht jeden Prototypen als Neuron mit Propagierungs- und Aktivierungsfunktion sehen (da diese ja bei allen Prototypen gleich sind), man muss also nicht einmal ein Netz dieser simulieren. Was ist dann besonders wichtig für die selbstorganisierende Karte?

\begin{enumerate}
\item Prototypen. Die wichtigsten Informationen, die diese tragen, sind ihre Repräsentationspunkte im mehrdimensionalen Raum und ihre Position im Prototypenraum (also in der Kohonenkarte). Die Datenpunkte, mit denen die Prototypen eine Gruppe bilden, müssen nicht explizit in Verbindung mit den Prototypen gebracht werden, da man diese Verbindung auch nachträglich noch ausrechnen kann.
\item Die Datenpunkte, da diese natürlich die wichtigsten Informationen enthalten. Sie tragen genauso wie die Prototypen eine Koordinate im mehrdimensionalen Raum.
\item Eine \(\alpha\)-Funktion (bzw. Alphafunktion). Diese wird benötigt, um klarzustellen, wie stark die Prototypen durch die Datenpunkte beeinflusst werden können. Sie nimmt die Position des Gewinnerprototypen entgegen und ordnet dann jedem Prototypen die beeinflussbarkeit dessen zu.
\end{enumerate}

Wie zu erkennen ist, ist die selbstorganisierende Karte im Wesen nicht sonderlich kompliziert. Mit wenigen Grundlagen kann man sie also realisieren.

\section{Erklärung und Vorstellung des Programms}

\subsection{Begründung der Wahl der Programmiersprache}

Unser Programm, um welches es in dieser Arbeit geht, ist in Haskell geschrieben. Haskell ist eine funktionale Programmiersprache und somit sehr anders aufgebaut als imperative, objektorientierte Programmiersprachen. Funktionalität bedeutet:

\begin{enumerate}
\item Keine Variable darf verändert werden. Dies ist einer der Grundsätze der funktionalen Programmierung, denn durch dieses Prinzip ist es formal egal, in welcher Reihenfolge Prozesse ausgeführt werden.
\item Eine Funktion gibt bei gleichen Parametern gleiche Ausgaben aus. Mit anderen Worten sind (die meisten) Funktionen in Haskell daher \glqq{}pure\grqq{} und verursachen keine \glqq{}side-effects\grqq{}, interagieren also nicht mit der Außenwelt.
\end{enumerate}

Dadurch entstehen allerdings Probleme bei In- und Output: Jede Funktion, die z.B. Eingaben vom Nutzer verarbeitet, ist \glqq{}impure\grqq{} (unrein), da ihre Ausgaben nicht nur von ihrer Parameterliste, sondern auch von der Außenwelt (dem Nutzer) abhängig sind. Haskell löst dieses Problem, indem jede Funktion, die Kontakt zur Außenwelt aufnimmt, markiert wird. Dies geschieht, indem Daten, die aus der Außenwelt stammen, in einem sogenanntem \glqq{}Monad\grqq{} verkapselt werden. Ein Monad ist eine Datenstruktur, deren Daten zwar weiter verarbeitet, aber nicht unbedingt aus dem Monad extrahiert werden können. Somit werden Daten, die durch In- und Output verursacht wurden (da es in Haskell keine Funktionen gibt, die nichts zurückgeben, da dies sinnlos wäre, geben auch Ausgabefunktionen etwas zurück) immer in einem \glqq{}IO-Monad\grqq{} gespeichert und können nicht wieder aus diesem extrahiert werden. Daher kann einfach bestimmt werden, ob eine Funktion mit der Außenwelt kommuniziert, indem die Typsignatur (besonders die Rückgabe der Funktion) beobachtet wird.

Des weiteren verfolgt Haskell die Philosophie der \glqq{}lazy evaluation\grqq{}, wodurch Variablen erst dann ausgewertet werden, wenn sie auch benötigt werden (z.B. wenn eine Variable ausgegeben werden muss). Dadurch wird Rechenzeit gespart, da unbenötigte Ergebnisse auch nicht berechnet werden. Auch gibt es eine effiziente Umsetzung von Rekursivität in Haskell, was viele Funktionen vereinfacht und eleganter macht. Schließlich kompiliert der Haskell Compiler (in dieser Seminarfacharbeit wurde der am weitesten verbreitete Glasglow Haskell Compiler, oder GHC, verwendet) den Quellcode direkt in Assemblercode, wodurch, anders als bei Java, das Programm maschinenfreundlich --- und damit schneller --- ausgeführt wird.

Für unser Programm brachten diese Umstände vor allem folgende Vorteile:

\begin{enumerate}
\item Die Schnelligkeit, die Haskell mit sich bringt, ist äußerst bedeutend. Weil eine selbstorganisierende Karte viele Daten verarbeiten muss, ist dieser Faktor nicht zu vernachlässigen.
\item Haskell ist eine Programmiersprache, die sich in äußerst kurzer und prägnanter Form schreiben lässt. Dadurch ist es oftmals einfacher, den Überblick über ein in Haskell geschriebenes Programm zu behalten --- es bedeutet jedoch nicht, dass es einfacher ist, Programme in Haskell zu schreiben, denn es ist eine höhere Konzentration zum Schreiben dieser benötigt.
\item Viele Datenstrukturen in Haskell sind wiederverwendbar: In den meisten objektorientierten Programmiersprachen trifft dies nicht zu. Stattdessen wird in jenen jede Datenstruktur für einen bestimmten Zweck verwendet, während Haskell darauf aufbaut, Datenstrukturen so abstrakt wie möglich zu halten.
\item Haskells eigenes \glqq{}build system\grqq{}, cabal, ist in der Haskell Plattform erreichbar. Somit wird es für den Programmierer einfacher, Bibliotheken von Anderen (welche in großer Qualität und Zahl vorhanden sind) in das eigene Programm einzubinden.
\item Schließlich läuft Haskell auch auf den meisten Betriebssystemen (Windows, Linux, OSX, \dots{}); Da es jedoch nicht nur einen Compiler gibt und die Sprache Haskell letztendlich nur eine Konvention ist, kann sie auch nach Bedarf auf andere Betriebssysteme übertragen werden.
\end{enumerate}

Der Leser sei an dieser Stelle angehalten, sich mit der Syntax Haskells bekannt zu machen, sodass Programmbeispiele später nachvollzogen werden können.

Es folgen Beschreibungen von Bibliotheken, die benutzt wurden. Dies soll dazu dienen, dem Leser das Verstehen des Programms zu erleichtern.

\subsubsection{Die Pipes-Bibliothek}

\subsubsection{Die Criterion-Bibliothek}

\subsection{Funktionsweise des abstrakten Teils}

\subsection{Erweiterung auf unsere Anwendung / Anpassung des Programms}

\subsection{Anwendung des Programms}

\end{document}

% useful things:
% --- TABLES ---
% \begin{table}[H]
% \caption{Example table}
% \centering
% \begin{tabular}{llr}
% \toprule
% \multicolumn{2}{c}{Name} \\
% \cmidrule(r){1-2}
% First name & Last Name & Grade \\
% \midrule
% John & Doe & $7.5$ \\
% Richard & Miles & $2$ \\
% \bottomrule
% \end{tabular}
% \end{table}
